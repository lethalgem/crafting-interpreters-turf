1. We have methods on instances, but there is no way to define “static” methods that can be called directly on the class object itself. 
Add support for them. Use a class keyword preceding the method to indicate a static method that hangs off the class object.

class Math {
  class square(n) {
    return n * n;
  }
}

print Math.square(3); // Prints "9".
You can solve this however you like, but the “metaclasses” used by Smalltalk and Ruby are a particularly elegant approach. 
Hint: Make LoxClass extend LoxInstance and go from there.


2. Most modern languages support “getters” and “setters”—members on a class that look like field reads and writes but that actually 
execute user-defined code. Extend Lox to support getter methods. These are declared without a parameter list. The body of the getter 
is executed when a property with that name is accessed.

class Circle {
  init(radius) {
    this.radius = radius;
  }

  area {
    return 3.141592653 * this.radius * this.radius;
  }
}

var circle = Circle(4);
print circle.area; // Prints roughly "50.2655".


3. Python and JavaScript allow you to freely access an object’s fields from outside of its own methods. Ruby and Smalltalk encapsulate 
instance state. Only methods on the class can access the raw fields, and it is up to the class to decide which state is exposed. 
Most statically typed languages offer modifiers like private and public to control which parts of a class are externally accessible 
on a per-member basis.

What are the trade-offs between these approaches and why might a language prefer one or the other?

3.a. I assume that the trade-off is ease of use / readability vs. safety. Where ease of use means the developer doesn't have to think 
about whether or not a field is accessible, they can just directly modify state anytime they please. It also meanst that setting and getting
are done with the same syntax instead of having a separate method for each function. It also means the developer doesn't have to spend time
defining a setter and a getter method for each piece of state they want to expose. By readability I mean that any developer can look at it 
and understand what field is being referenced. Ex. circle.radius vs circle.get_radius(). In this case it's pretty obvious. In this, it isn't
Ex. circle.get_info() -- returns radius.

Safety means safety from errors and unintended side effects. By having public and private control of state, it prevents the developer from
accidentally modifying state when they do not intend to. If they can directly access circle.radius, then it wouldn't be to far of a stretch
to imagine that they accidentally assigned a new value to it instead of reading the value. Ex. circle.radius = 4 instead of circle.radius == 4
or similar. Although tbf I can't think of a scenario where an assignment would be accepted where a conditional is expected.

It would also make bug hunting easier if you know that only the instance of the class is able to modify it's state and not externals. You simply
need to look for whatever call to the setter is made to know when and where state may be modified outside of the instance itself.

After a google search I found: https://github.com/munificent/craftinginterpreters/blob/master/note/answers/chapter12_classes.md

"The decision to encapsulate at all or not is the classic trade-off between whether you want to make things easier for the class consumer or the 
class maintainer. By making everything public and freely externally visible and modifier, a downstream user of a class has more freedom to pop 
the hood open and muck around in the class's internals."

This also brought up in my mind the idea of coupling various parts of the codebase together. With control over private and public access the 
developer can choose whether or not to isolate the class and it's behavior or have it depend on other classes and scripts.
