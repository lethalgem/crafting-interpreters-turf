1. Our interpreter carefully checks that the number of arguments passed to a function matches the number of parameters it expects. 
Since this check is done at runtime on every call, it has a performance cost. Smalltalk implementations don’t have that problem. 
Why not?

1.a. From what I've found, functions are do not do any checks on arguments. As to why, I'm not sure.

2. Lox’s function declaration syntax performs two independent operations. It creates a function and also binds it to a name. 
This improves usability for the common case where you do want to associate a name with the function. But in functional-styled code, 
you often want to create a function to immediately pass it to some other function or return it. In that case, it doesn’t need a name.

Languages that encourage a functional style usually support anonymous functions or lambdas—an expression syntax that creates a 
function without binding it to a name. Add anonymous function syntax to Lox so that this works:

fun thrice(fn) {
  for (var i = 1; i <= 3; i = i + 1) {
    fn(i);
  }
}

thrice(fun (a) {
  print a;
});
// "1".
// "2".
// "3".

How do you handle the tricky case of an anonymous function expression occurring in an expression statement:

fun () {};

3. Is this program valid?

fun scope(a) {
  var a = "local";
}

In other words, are a function’s parameters in the same scope as its local variables, or in an outer scope? 
What does Lox do? What about other languages you are familiar with? What do you think a language should do?

3.a. Lox does not error, so that's good. I ran:

fun scope(a) {
  var a = "local";
  print(a);
}

scope("yes");

and the result was "local". So the parameter must be held in the outer scope and a local variable by the same
name can be declared.

In some other languages (rust) they do allow shadowing of parameters. Aka creating a local variable by the same 
name that overrides the passed in parameter when referenced locally. Some other languages also allow parameters to
be mutable, but I don't think you'd be able to redeclare the variable locally, just access and mutate it.

I am of two minds on what I think a language should do. There is an inherent risk to redeclaring the parameter
and trying to use it later on only to use the local variable instead. At the same time, in rust, it has proven
to be useful. There are times when you want to pull in the parameter, then modify it. Redeclaring as a local
gives you that mutability, whereas the parameter may be immutable. Ex. var a = a + "local"; Adds "local" to the 
parameter for use in the local scope.