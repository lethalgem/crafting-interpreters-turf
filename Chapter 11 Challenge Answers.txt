1. Why is it safe to eagerly define the variable bound to a function’s name when other variables 
must wait until after they are initialized before they can be used?

1.a. 

2. How do other languages you know handle local variables that refer to the same name in their 
initializer, like:

var a = "outer";
{
  var a = a;
}

Is it a runtime error? Compile error? Allowed? Do they treat global variables differently? Do 
you agree with their choices? Justify your answer.

2.a. Rust has no issues with local variables referring to the same name in their initializer.
Playground link: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b1ddb72e7edd69ba5f103b297b93af60

Since I write so much rust these days, I do agree with the choice. Each code block is it's own
scope so I would expect that redeclaring a variable would just pull the variable from the outerscope.
I believe this also works in rust because everything is immutable by default. So I am really just
pointing to the outerscope variable with this declaration.

3. Extend the resolver to report an error if a local variable is never used.

3.a. See implementation in Resolver.Java. I added a class to the `scopes` map that includes a flag for
whether or not the variable had been used. I update this flag to true in resolveLocal(). Then when we
endScope() I loop over the variables in the map and error on any that were unused. This also covers the 
scenario of accessing the variables in nested scopes.

4. Our resolver calculates which environment the variable is found in, but it’s still looked up 
by name in that map. A more efficient environment representation would store local variables in 
an array and look them up by index.

Extend the resolver to associate a unique index for each local variable declared in a scope. When 
resolving a variable access, look up both the scope the variable is in and its index and store that. 
In the interpreter, use that to quickly access a variable by its index instead of using a map.